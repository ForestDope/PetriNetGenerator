# src/petri_net_utils.py
import json
from graphviz import Digraph, CalledProcessError
from pathlib import Path
import shutil # For checking if dot is in PATH

def petri_json_to_dot(petri_json_data: dict, filename: str, output_dir: Path) -> tuple[Path | None, Path | None]:
    """
    Converts Petri Net JSON to DOT, saves .gv and renders .pdf to the specified output_dir.
    The final filenames will be filename.gv and filename.pdf.

    Args:
        petri_json_data (dict): The Petri Net data.
        filename (str): Base name for output files (e.g., "candidate_xxxx"). No extensions.
        output_dir (Path): Directory to save .gv and .pdf files.

    Returns:
        tuple: (Path_to_pdf, Path_to_gv) if PDF and GV successful,
               (None, Path_to_gv) if PDF fails but GV saves,
               (None, None) if both fail.
    """
    if not isinstance(petri_json_data, dict):
        print("  Error (petri_json_to_dot): Input petri_json_data must be a dictionary.")
        return None, None
    if not filename:
        print("  Error (petri_json_to_dot): Filename cannot be empty for visualization.")
        return None, None
    if not isinstance(output_dir, Path):
        print("  Error (petri_json_to_dot): output_dir must be a Path object.")
        return None, None

    output_dir.mkdir(parents=True, exist_ok=True)

    dot_graph = Digraph(name=filename, comment=f'Petri Net: {filename}')
    dot_graph.attr(rankdir='LR', fontsize='10')
    dot_graph.graph_attr['splines'] = 'true'
    dot_graph.graph_attr['nodesep'] = '0.5'
    dot_graph.graph_attr['ranksep'] = '0.75'

    places = petri_json_data.get("places", {})
    transitions = petri_json_data.get("transitions", {})
    arcs = petri_json_data.get("arcs", [])
    initial_marking = petri_json_data.get("initial", {})

    for p_id, p_label in places.items():
        display_label = (p_label[:25] + '...') if len(p_label) > 25 else p_label
        full_node_label = f"{display_label}\nID: {p_id}"
        node_attrs = {'shape': 'ellipse', 'style': 'filled', 'fillcolor': 'lightblue', 'fontsize': '9'}
        if p_id in initial_marking:
            tokens = initial_marking[p_id]
            node_attrs['penwidth'] = '2'
            full_node_label += f"\n({tokens} token{'s' if tokens > 1 else ''})"
        dot_graph.node(p_id, label=full_node_label, **node_attrs)

    for t_id, t_label in transitions.items():
        display_label = (t_label[:25] + '...') if len(t_label) > 25 else t_label
        full_node_label = f"{display_label}\nID: {t_id}"
        dot_graph.node(t_id, label=full_node_label, shape='box', style='filled', fillcolor='lightgray', fontsize='9')

    for arc_idx, arc in enumerate(arcs):
        arc_from, arc_to = arc.get("from"), arc.get("to")
        if arc_from and arc_to:
            dot_graph.edge(arc_from, arc_to)
        else:
            print(f"  Warning (petri_json_to_dot): Skipping invalid arc (index {arc_idx}) in visualization: {arc}")

    output_stem_path = output_dir / filename
    gv_file_path = Path(f"{output_stem_path}.gv")
    pdf_file_path = Path(f"{output_stem_path}.pdf")

    # Clean up any pre-existing files with these names to avoid confusion from previous runs
    if gv_file_path.exists(): gv_file_path.unlink(missing_ok=True)
    if pdf_file_path.exists(): pdf_file_path.unlink(missing_ok=True)

    rendered_pdf_actual_path_str = None
    try:
        # render() will create BOTH the .gv file (named `filename` in `directory`)
        # AND the .pdf file (named `filename.pdf` in `directory`).
        # cleanup=False keeps the .gv file it creates.
        rendered_pdf_actual_path_str = dot_graph.render(
            filename=filename,
            directory=str(output_dir),
            format='pdf',
            cleanup=False, # Keep the .gv file generated by this render call
            quiet=True
        )
        
        if pdf_file_path.exists() and gv_file_path.exists():
            # print(f"  Visualization DOT definition saved to: {gv_file_path.resolve()}") # Redundant if render creates it
            # print(f"  Visualization rendered to PDF at: {pdf_file_path.resolve()}")
            return pdf_file_path, gv_file_path
        elif gv_file_path.exists():
            print(f"  Visualization DOT saved to: {gv_file_path.resolve()} (PDF rendering FAILED or file mismatch: expected '{pdf_file_path}', render reported '{rendered_pdf_actual_path_str}')")
            return None, gv_file_path
        else:
            print(f"  Error (petri_json_to_dot): Both GV and PDF file creation failed for '{filename}' in '{output_dir}'. Render reported: {rendered_pdf_actual_path_str}")
            return None, None

    except CalledProcessError as cpe:
        print(f"  Error (petri_json_to_dot): Graphviz 'dot' command failed during PDF rendering for '{filename}'.")
        print(f"  Command: {' '.join(cpe.cmd) if cpe.cmd else 'Unknown'}")
        print(f"  Return Code: {cpe.returncode}")
        print(f"  Stdout: {cpe.stdout.decode(errors='ignore') if cpe.stdout else 'N/A'}")
        print(f"  Stderr: {cpe.stderr.decode(errors='ignore') if cpe.stderr else 'N/A'}")
        if shutil.which("dot") is None:
            print("  CRITICAL: The 'dot' command (Graphviz executable) was not found in your system's PATH.")
        print("  Ensure Graphviz is installed correctly and its 'bin' directory is in your system's PATH.")
        if gv_file_path.exists(): return None, gv_file_path
        return None, None
    except Exception as e:
        print(f"  Error (petri_json_to_dot): Unexpected error during rendering for '{filename}': {e}")
        if gv_file_path.exists(): return None, gv_file_path
        return None, None